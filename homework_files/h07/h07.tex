\documentclass{article}
%\usepackage[margin=0.5in]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\lstset{
	keywordstyle=\color{red},
	stringstyle=\color{blue},
	tabsize=2,
}

\title{Homework 07 - Poster Text}
\author{Andrew Carter and Beryl Egerter}

\begin{document}
\maketitle

\section{Title}
A Qualitative Analysis of Code Comprehension and Debugging Strategies

\section{Abstract}
We performed a qualitative analysis on a study consisting of four interviews of college students with varying amounts of experience beyond basic programming. In the interviews, we asked the students to perform code comprehension or debugging on four or five code samples with varying levels of difficulty. Some code samples included programming concepts or syntax unfamiliar to the students. We are interested in the different strategies the students used for exploring unfamiliar code and have qualitatively analyzed how well the strategies worked on our code samples. Strategies we saw included students delving into the details of a function or obtaining a high level summary of a function from the name. Some students even changed strategies depending on the given task. We believe evaluating these strategies is important because the strategies can affect the success or failure of programmers trying to maintain, change, or interact with code written by others. These situations often occur in industry. Our study shows that programmers may change strategy based on problem type and complexity, of which future research may need to be careful about.

\section{Introduction}
While many studies have looked at code comprehension strategies and many studies have looked at debugging methodology, we were interested in how a student's strategy changes between these tasks. We performed a study on code comprehension involving evaluation or debugging on different code samples. Evaluation is figuring out what a piece of code will output, while debugging is looking through a piece of code to identify the cause of a specific problem. For this poster we have qualitatively analyzed one student's response to an evaluation question and a debugging question. We found that while the student could have followed the execution of the program in both code samples, while evaluating, he followed the execution, but while debugging, he searched top down for where the problem could occur.  

\section{Methods}

\subsection{Data Collection}
We designed our data collection to capture the code comprehension of a student looking at pieces of paper containing code in the programming language Python. A camera was set up to capture the hands of the student interacting with pen and paper as well as audio of anything they said out loud. At times the student was prompted by the interviewers to provide more information. 

\subsection{Problem 1.1}
\subsubsection{Description}
In this evaluation question, we asked, "For this question we would like you to familiarize yourself with some Python code. Please explain to us what you think this code does." 
\subsubsection{Code}
\begin{lstlisting}[language=python]
def func2(list, num):
		return func1(list, num, func4)

def func4(a, b):
		return a * b

def func1(list, num, f):
		acc = 0
		for i in list:
				acc += f(i, num)
		return acc

def main():
	print(func3([1,2,3,4]))

def func3(list):
	return func2(list, 4)

main()

\end{lstlisting}
\subsubsection{Solution}
This code prints out the number 40.
\subsection{Problem 2.2}
\subsubsection{Description}
In this debugging question, we asked, "For this question we would like to have you look at some code in Python. This is the scenario: You acquired a connect 4 program from a friend. However, the friend has warned you that you can put too many pieces in a column. Determine a possible fix for this bug so that you can enjoy your connect 4 program."
\subsubsection{Code (First 13 lines)}
\begin{lstlisting}[language=python]
#!/bin/env python3

class Board(object):
	def __init__(self, width=7, height=6):
		self.board = [[] for i in range(width)]
		self.width = 7
		self.height= 6
	
	def drop(self, player, column):
		if column < len(self.board):
			self.board[column].append(player)
			return True
		return False
\end{lstlisting}
\subsubsection{Solution}
While there could have been multiple solutions, we were looking for students to tell us to add an extra check within the drop function checking if the length of the list representing the column was full.

\section{Narration of Data}

The student begins talking as soon as he is handed the question,

ACBE3, Q1.1 \\
\begin{quote}
1:55 : Alright umm, so, its got a main, so thats gonna start ummm, its going to print whatever the result of \\
2:00 : function 3 on 1, 2, 3, 4, some array. So lets see, \\
2:05 : Function 3 takes a list and returns whatever function  2 does called with list \\
2:10 : and some argument 4. Function 2 returns function 1 \\
2:15 : with the same two arguments already passed to it, and \\
2:20 : function 4 the result of, which doesn't have any \\
2:25 : implied arguments, thats interesting. Umm, \\
2:30 : ... \\
\end{quote}

The student identifies main, and then is able to quickly trace through the program through func2.
When the student arrives at func2, he identifies function 4, which is in the argument list, but is confused because no arguments are being passed to the function.
He is further confused, because the function arguments do not have any default values, which would indicate that func4 could be called without arguments.
Although in python syntax it still would require parenthesis, which make this odd.

\begin{quote}
2:35 : thats odd, lets see, so its calling functi-, ooh, \\
2:40 : its calling function 1. There we go. Uhh, yes, so its calling function 1 with a list a number, the array \\
2:45 : and 4, and the function 4 as sort of a multiplier. A function to apply. \\
\end{quote}

He then looks at function 1, is able to identify the use of f in function 1, which is what is passed as function 4.
The student then works out the semantics of passing functions from how the code functions.

\begin{quote}
2:50 : Alright, so function 1 is doing the actual work here. Umm, see, it starts with some accumulator 0,  \\
2:55 : iterates across the uh items in the list, list, \\
3:00 : and plus equals that function 4 applied \\
3:05 : to i being the item from the list and that number 4 that was included in function 3. \\
3:10 : So its going to essentially sum the list multiplied by 4, \\
3:15 : it would appear, and print that sum out. \\
3:20 : Yeah, its gonna take, each element 1 2 3 4 and multiply it by 4 \\
3:25 : add that to 0 and then return the accumulator \\
3:30 : back up the steps. So function 1 2 3 yeah. \\
\end{quote}

Once he understands passing functions, he quickly figures out what the inner function does, then unwinds the functions and determines what the overall program does.

ACBE3, Q2.2 

\section{Discussion}
The student uses two different strategies to solve the problem in each section. While there are differences between the code used in each problem such as one being much longer than the other, and one including a class as opposed to a number of functions, they both have a piece of code that executes. In the first problem, when the student is told to figure out what the code does, he follows the thread of execution. In the other code sample, when the student is first told the overall function of the code and a bug to fix, the student started from the top of the file and moved down until finding a likely area the bug could be fixed. It would have been possible to start with where the program started executing and trace the thread of execution to where the pieces drop. In fact, by looking through the code from the top and stopping at the drop function, the student doesn't actually know if this function is ever used. The student is assuming the author of the program wrote it well. 

\section{Future Work}
In future work, we hope to explore more decisions of students and the impact on their code evaluation.
For instance, one of the students we interviewed switched things up between evaluation questions based on the perceived complexity of the code.
Another evaluated all of the questions starting at the top, but had varying degrees of success depending on the problem.
A couple of students read through the entire code base for the debugging problems, and got bogged down, we would like to explore the advantages and disadvantages of familiarizing with the entire code base, compared with determining the high level functions of all of the code, or determining where the most likely location of the bug is without regard to anything else.
\end{document}
